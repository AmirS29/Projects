\documentclass{report}
\setlength{\parindent}{0pt} % Sets the automatic indent size
\usepackage{graphicx} % Required for inserting images
\usepackage{pictex}   % Ensure PicTeX is available
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}


\lstset{
    language=C++,
    basicstyle=\ttfamily\tiny,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    numbers=none,
    numberstyle=\tiny,
    stepnumber=1,
    breaklines=true,
    frame=single,
    captionpos=b,
    showstringspaces=false
}

\title{HW\#8}
\author{
Elhaam Bhuiyan,
Amir Samarxhiu,
Shaqib Syed
}
\date{May 11, 2025}

\begin{document}

\maketitle

\section*{Introduction}
This report presents a model-based approach to estimating the historical daily volatility of ExxonMobil (XOM) stock returns over a ten-year period using a Hidden Markov Chain (HMC) framework. Unlike classical volatility models, such as the Exponentially Weighted Moving Average (EWMA), the HMC model treats the true volatility as an unobservable (hidden) process that evolves as a random walk in discrete time. Specifically, we model the volatility at time $t$, denoted $\sigma_t$, as
\[
\sigma_t = \sigma \exp(\alpha W_t),
\]
where $W_t$ is a simple symmetric random walk on the integers, and $\sigma$, $\alpha$ are fixed parameters set to 1.74 and 0.05 respectively. Observed returns $R_t$ are modeled as Gaussian random variables with zero mean and time-varying standard deviation $\sigma_t$, independent of the hidden process. \\

The core of the model implementation involves recursive Bayesian updating to compute the posterior distribution of the hidden state $W_t$ given observed returns up to time $t-1$. Using the Maximum a Posteriori (MAP) estimate of this distribution, we infer the most likely volatility at each time step. The estimated volatility series is then annualized and compared graphically and statistically to that produced by the EWMA model. Additional analysis includes scatter plots of the two volatility estimates, a histogram of standardized returns, and a time series plot of these standardized returns to evaluate model fit and residual behavior. \\

\newpage

\section*{Results}

This time series graph displays the historical daily volatility (annualized in percentage terms) of ExxonMobil (XOM) from 2013 to 2023. Volatility spikes notably during periods of market stress, such as in early 2020, corresponding to the COVID-19 crisis. The dashed horizontal line represents the constant annual estimated volatility, 27.66\%. Volatility values fluctuate above and below this line, indicating dynamic risk over time. \\


\beginpicture
\setcoordinatesystem units <.002truein, .02truein> 
\setplotarea x from 0 to 2540, y from  0 to 100
\put {XOM Historical Volatility} at 1270 105
\axis left 
 label {Vol (\%)} 
 ticks   numbered from  0 to 100 by 10  
 /
\axis bottom
/
\multiput {$|$} at  214 -9  466 -9 718 -9 970 -9 1222 -9 1474 -9 1726 -9 1978 -9 2230 -9 2482 -9  /
\put {$2014$} at 107 -9
\put {$2015$} at 340 -9
\put {$2016$} at 592 -9
\put {$2017$} at 844 -9
\put {$2018$} at 1096 -9
\put {$2019$} at 1348 -9
\put {$2020$} at 1600 -9
\put {$2021$} at 1852 -9
\put {$2022$} at 2104 -9
\put {$2023$} at 2356 -9
\setplotsymbol ({$\scriptscriptstyle\cdot$})
\plot "EWMA.txt"
\setsolid
\setplotsymbol ({$\cdot$})
\plot "HMC.txt"
\setdashes
\plot 0 27.66 2540 27.66 /
\endpicture\vfill









\newpage

This scatterplot compares the volatility estimates from two models. The x-axis shows EWMA (Exponentially Weighted Moving Average) volatility estimates, while the y-axis shows Hidden Markov Chain (HMC) volatility estimates, calculated as:
\[
y_t = \sqrt{252} \, \sigma b_t
\]
where \( b_t = \exp(\alpha W_t) \), \( \sigma \) is the base volatility, 1.74, and \( W_t \) is a symmetric random walk process. \\

This formula gives the annualized daily volatility of the HMC model in percentage terms. The dashed diagonal line is the identity line \( y = x \), which represents where both models would produce equal volatility estimates. Points above the line indicate that the HMC model estimated a higher volatility than EWMA for that observation, while points below suggest the reverse. From the graph, estimations for EWMA are lower than hidden Markov chains.

\begin {center}

\beginpicture
\setcoordinatesystem units <   .03 truein, .03 truein>
\setplotarea x from 0 to 100, y from  0 to 100
\axis left
ticks    numbered from  0 to 100 by 10
/
\put {Hidden} [cr] at -10 55
\put {Markov} [cr] at -10 50
\put {Chain} [cr] at -10 45
\axis bottom
label {EWMA}
ticks  numbered from 0 to 100 by 10
/
\plot 0 0  100 100 /
\plot 0 100  100 100  100 0 /
\multiput {$\cdot$} at "ScatterData.txt"
\endpicture\vfill\end{center}

\newpage






To evaluate the model’s performance in capturing time-varying volatility, we generate a histogram of the standardized returns:
\[
z_t = \frac{r_t}{\sigma b_t}, \quad 51 \leq t < T,
\]
where $r_t$ is the return and $\sigma b_t$ is the estimated volatility from the Hidden Markov Chain (HMC) model.

We plotted the histogram of $z_t$ using 20 equally spaced buckets. This visualization helps to assess whether the standardized returns approximate a standard normal distribution $\mathcal{N}(0,1)$.

The resulting histogram closely resembles the bell-shaped curve of a standard normal distribution, indicating that the volatility model has effectively normalized the return series. This suggests that the HMC model has effectively accounted for the changing volatility in the data and that the residuals (standardized returns) behave like a standard normal distribution.



\begin {center}
\beginpicture
\setcoordinatesystem units <0.45 truein, 1.5 truein>
\setplotarea x from -5 to 5, y from  0 to 1.0
\axis bottom
ticks numbered from -5 to 5 by 1
/
\plot "Normal.txt"
\plot -5.2 0 -5.1 0 -5.1 1  -5.2 1 /
\put {0} [cr] at -5.3 0
\put {$\frac{1}{\sqrt{2\pi}}$} [cr] at -5.3 1
\put {\sl Standard Normal Histogram} at 0 1.2
\sethistograms
\plot "HistogramData.txt"
\endpicture\vfill\end{center}
\newpage





The plot below displays the standardized returns for Exxon Mobil (XOM) from 2014 to 2024. These are calculated as
\[
\frac{r_t}{\hat{\sigma}_t},
\]
where $r_t$ is the observed daily return and $\hat{\sigma}_t$ is the estimated daily volatility using the Hidden Markov Chain (HMC) model. \\

The plot shows that the standardized returns are mostly within these bounds, suggesting that the HMC model provides a good fit. Some extreme values remain, particularly during periods of high market stress, which may reflect genuine heavy-tailed behavior in financial markets. \\

\begin {center}

\beginpicture
\setcoordinatesystem units <.002truein, .1truein> 
\setplotarea x from 0 to 2540, y from  -8 to 8
\put {Standardized Return Time Series} at 1255 8.5
\axis left 
 %label {(\%)} 
 ticks   numbered from  -8 to 8 by 2  
 /
\axis bottom
/
\multiput {$|$} at  214 -9  466 -9 718 -9 970 -9 1222 -9 1474 -9 1726 -9 1978 -9 2230 -9 2482 -9  /
\put {$2014$} at 107 -9
\put {$2015$} at 340 -9
\put {$2016$} at 592 -9
\put {$2017$} at 844 -9
\put {$2018$} at 1096 -9
\put {$2019$} at 1348 -9
\put {$2020$} at 1600 -9
\put {$2021$} at 1852 -9
\put {$2022$} at 2104 -9
\put {$2023$} at 2356 -9
\plot "StandardizedXOM.txt"
\setdashes
\plot 0 3  2540 3 /     
\plot 0 -3 2540 -3 /
\endpicture\vfill\eject
\end {center}



\section*{Conclusion}

In conclusion, this report applied a Hidden Markov Chain (HMC) model to estimate the time-varying volatility of ExxonMobil (XOM) returns over a 10-year period using hidden Markov chains. The results show that while both the EWMA and HMC models yield similar trends, the HMC model often produces higher volatility estimates during periods of market stress. \\

The scatter plot and the standardized return analysis suggest the HMC model captures volatility dynamics effectively, with residuals mostly within $\pm3$ standard deviations and close to a normal distribution. \\

Overall, the HMC model offers a flexible, probabilistic alternative to classical methods. Future work could explore extensions to capture asymmetric volatility or fat-tailed behavior for improved realism and robustness. \\


\section*{Contributions:}
We all worked together on the coding of each problem to ensure that there were no discrepancies. We provided feedback and clarified the details throughout the process, refining our implementations until all discrepancies were resolved. Once we finalized the code, we worked on the report together, and we made sure to include sufficient detail, ensure proper formatting, and maintain clarity throughout.

\newpage
\section*{Appendix:}
Code for Problems:
\begin{lstlisting}[language=C++]
////////////////////////////////////////////////////////////////////////////////
// Starter code for Homework 8.
////////////////////////////////////////////////////////////////////////////////


// These functions are found below.
void    GetData ();
void    Report ();
double  f (double, double);
double *AllocateMemory ();

// Number of items of data in the XOM return time series.
int T = 2540;

// These global variables are used to reduce function arguments.
double *R, *R2, *sigma_hat, *EWMA, *s, *p, *ptilde, *g;

#include "Functions.h"

int main () {

   int t;

   // Read in the time series data.
   GetData ();

   // Implement the hidden Markov chain model between here...

   // Initialize the probability distribution
   p[0] = 1.0;  // Start with W0 = 0

   // Precompute s_k = σ * exp(α * k)
   double sigma = 1.74;
   double alpha = 0.05;
   for (int k = -T; k <= T; ++k) {
       s[k] = sigma * exp(alpha * k);
   }

   for (t = 0; t <= T; ++t) {

       // Find MAP estimate of k (argmax of p[k])
       int k_star = 0;
       double max_prob = 0.0;
       for (int k = -t; k <= t; k += 2) {
           if (p[k] > max_prob) {
               max_prob = p[k];
               k_star = k;
           }
       }
       sigma_hat[t] = s[k_star];

       // Stop if we're at the end of the time series
       if (t == T) break;

       // Compute denominator for update
       double denom = 0.0;
       for (int j = -t; j <= t; j += 2) {
           denom += f(R[t], s[j]) * p[j];
       }

       // Update probabilities for next time step
       for (int k = -(t + 1); k <= (t + 1); k += 2) {
           double num = 0.0;
           if (k - 1 >= -t) num += f(R[t], s[k - 1]) * p[k - 1];
           if (k + 1 <= t) num += f(R[t], s[k + 1]) * p[k + 1];
           ptilde[k] = 0.5 * num / denom;
       }

       // Store new probabilities
       for (int k = -(t + 1); k <= (t + 1); k += 2) {
           p[k] = ptilde[k];
       }
   }

   // ... and here.

   // Create TeX files for viewing results.
   Report ();

   Pause ();
}


////////////////////////////////////////////////////////////////////////////////
// Normal(0,s^2) density function.
////////////////////////////////////////////////////////////////////////////////
double f(double r, double s) {

   static double sqrt2pi = 2.506628;

   // Some values of s are so small that they result in division by zero below.
   if (s < 1e-10) {
      return 0.0;
   }

   // This is the general case.
   else {
      return exp(-r*r/(2.0*s*s))/(sqrt2pi*s);
   }

}


////////////////////////////////////////////////////////////////////////////////
// Read in a daily time series of stock price returns R[t] 0 <= t < T.
// Allocate array space for the model
////////////////////////////////////////////////////////////////////////////////
void GetData () {

   int t, n;
   char input[100];
   FILE *fp;

   fp = fopen ("XOM-Daily-10Yrs.txt", "r");

   // Read in the file description.
   fgets (input, 99, fp);

   // Allocate memory for the data, initialized to 0.
   R         = List (T);
   R2        = List (T);
   sigma_hat = List (T);
   EWMA      = List (T);

   // Allocate necessary memory for the HMC model.
   s      = AllocateMemory (); // You may now refer to s[-T] through s[T].
   p      = AllocateMemory (); // Same comment about p, ptilde, and g.
   ptilde = AllocateMemory (); // The magic of pointer arithematic!
   g      = AllocateMemory (); // Can't do that in Python.

   // Now read in the XOM return data (in percent).
   for (t = 0; t < T; t++) {
      fgets (input, 99, fp);
      sscanf (input, "%lf", R+t);
      R2[t] = R[t] * R[t];  // Return-squared
   }
   fclose (fp);

   // Now read in the EWMA data (for purposes of the scatter plot).
   fp = fopen ("EWMA.txt", "r");
   for (t = 51; t <= T; t++) {
      fgets (input, 99, fp);
      sscanf (input, "%d %lf", &n, EWMA+t);
   }
   fclose (fp);

   return;

}

////////////////////////////////////////////////////////////////////////////////
// Generate some output files.
////////////////////////////////////////////////////////////////////////////////
void Report () {

   int t;
   double annualizedVol, Z;
   FILE *fp1, *fp2;

   // First create a time series of HMC estimated annualized volatility,
   //    and standardized XOM return.

   // Create scatter plot and volatility time series data files.
   fp1 = fopen ("ScatterData.txt", "w");
   fp2  = fopen ("HMC.txt", "w");

   // Here "t" can include T.
   for (t = 51; t <= T; t++) {
      annualizedVol = sqrt(252.0) * sigma_hat[t];
      fprintf (fp1, "%6.2f  %6.2f\n", EWMA[t], annualizedVol);
      fprintf (fp2, "%4d %10.2f\n", t, annualizedVol);
   }
   fclose (fp1);
   fclose (fp2);

   // Report standardized return information. Here "t" cannot include T.
   fp1 = fopen ("StandardizedXOM.txt", "w");
   for (t = 51; t < T; t++) {

      // Standardize the data.
      Z = R[t] / sigma_hat[t];

      // Add the standardized return to the histogram with 20 buckets.
      NormalHistogram (Z, 20, 0);

      // Now put it into the time series file
      fprintf (fp1, "%4d  %6.3f\n", t, Z);

   }
   fclose (fp1);

   // Create histogram TeX file.
   NormalHistogram (0, 20, 1);
 
   return;

}

////////////////////////////////////////////////////////////////////////////////
// Allocate memory for an array with indices from -T to +T.
// This is a little more than needed.
////////////////////////////////////////////////////////////////////////////////
double *AllocateMemory () {

   double *x;

   x = (double *) calloc (2*T + 1, sizeof (double));

   x += T;

   return x;

}

\end{lstlisting}

\end{document}

\documentclass{report}
\setlength{\parindent}{0pt} % Sets the automatic indent size
\usepackage{graphicx} % Required for inserting images
\usepackage{pictex}   % Ensure PicTeX is available
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{booktabs}


\lstset{
    language=C++,
    basicstyle=\ttfamily\tiny,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    numbers=none,
    numberstyle=\tiny,
    stepnumber=1,
    breaklines=true,
    frame=single,
    captionpos=b,
    showstringspaces=false
}

\title{HW\#7}
\author{
Elhaam Bhuiyan,
Amir Samarxhiu,
Shaqib Syed
}
\date{\today}

\begin{document}

\maketitle

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

In this project, we use Monte Carlo simulation to price European call options on ExxonMobil (XOM) using a GARCH(1, 1) volatility model. While the Black-Scholes framework assumes volatility is flat, real-world markets exhibit time-varying volatility that tends to cluster following large price movements. GARCH captures this behavior by updating daily variance with:

\[
\sigma_t^2 = \alpha \sigma_{\text{LT}}^2 + \beta R_{t-1}^2 + \gamma \sigma_{t-1}^2
\]

where $R_t = \sigma_t\epsilon_t$ with $\epsilon_t \sim N(0, 1)$, and $\alpha + \beta + \gamma = 1$. Here, $\sigma_{\text{LT}}^2 = (0.30)^2\Delta t$ and $\sigma_0^2 = (0.21)^2 \Delta t$ with $\Delta t = \frac{1}{252}$, so that all variances and returns are in daily units. \\

Starting from $S_0 = 116.99$, a continuously compounded risk-free rate $r = 0.05$ per year and a time to expiration of $T = 126 \text{ days}$, we simulate stock paths by drawing standard normal $Z$ and setting:
\[
R = \sigma_{t-1}Z,\quad \mu = r \Delta t - \frac{1}{2}\sigma_{t-1}^2
\]
Then update:
\[
S_t = S_{t-1}\exp(\mu + R),\quad \sigma_t^2 =\alpha \sigma_{\text{LT}}^2 + \beta R^2 + \gamma \sigma_{t-1}^2
\]

To reduce estimator variance, we use antithetic variables $(Z, -Z)$ and terminate the simulation once all estimated option prices achieve a 95\% confidence interval half-width of at most \$0.01. \\

We first validate our implementation by pricing a zero-strike call, whose payoff is $S_T$, and verifying that the present value is consistent with the initial spot price. We then price call options with strikes ranging from 80 to 180 in increments of 10, compute their Black-Scholes implied volatilities, and plot the resulting implied volatility curve on a fixed vertical scale from 20\% to 30\%, including 95\% confidence intervals. \\

This analysis is repeated for three different GARCH parameter sets: 1. $\alpha = 0, \beta = 0, \gamma = 1$, 2. $\alpha = 0.02, \beta = 0, \gamma = 0.98$, and 3. $\alpha = 0.007, \beta = 0.080, \gamma = 0.913$. We compare the volatility curves that result under each setting and discuss how the different volatility dynamics influence their shape.

\newpage






\section*{Question 1: Pricing a Call with Strike \( K = 0 \)}
\addcontentsline{toc}{section}{Question 1}

Using the GARCH(1,1) framework introduced above, we estimate the price of a European call option with strike \( K = 0 \), which by definition has a pay-off \( S_T \) at maturity. \\

We implemented the simulation on a horizon of \( T = 0.5 \) years (126 trading days), starting from an initial price \( S_0 = 116.99 \) and daily volatility initialized at 21\% annualized. The GARCH (1,1) parameters used are
\[
\alpha = 0.007, \quad \beta = 0.080, \quad \gamma = 0.913
\]
and the long-term volatility is set to 30\% annually. \\

The simulation updates stock prices and variance at each time step, using antithetic sampling to reduce variance: for each random shock \( Z_t \), we simulate both \( Z_t \) and \( -Z_t \), averaging their outcomes. \\

The estimated resulting option price with an error tolerance of 0.01 or less is:
\[
\hat{C}_0 \approx 116.99511
\]

This value is remarkably close to the initial stock price \( S_0 = 116.99 \), differing by less than 0.01. This validates our simulation since the present value of a call option with zero strike should closely match the current spot price. \\

\newpage









\section*{Question 2: Implied Volatility for \(\alpha = 0, \beta = 0, \gamma = 1\)}
\addcontentsline{toc}{section}{Question 2: \(\alpha = 0, \beta = 0, \gamma = 1\)}

With parameters \( \alpha = \beta = 0, \gamma = 1 \), the volatility process becomes:

\[
\sigma_t^2 = \sigma_{t-1}^2
\]

This implies the daily variance remains constant over time. There are no updates from either \( \alpha = 0 \) or  \( \beta = 0 \), as well as  \( \gamma = 1 \). As a result, the volatility process is flat; meaning for each day, the volatility is the same as the previous day. \\

This behavior replicates the constant volatility assumption of the Black-Scholes model. Accordingly, the implied volatility across different strike prices remain nearly flat and show minimal variation. The tight confidence intervals in our simulation reflect the absence of stochastic behavior in the volatility path, leading to a reduced estimation of uncertainty. \\




\begin{figure}[h!]
\centering
\beginpicture
\setcoordinatesystem units <.04truein, .2truein> 
\setplotarea x from 75 to 185, y from 19 to 29
\put {Implied Volatility with Confidence Intervals (Question 2)} at 130 29
\axis left ticks numbered from 19 to 29 by 1 /
\axis bottom ticks numbered from 80 to 180 by 10 /
\setplotsymbol ({$\cdot$})
\plot 80 20.9980 80 20.4970 80 21.4240 /
\plot 90 20.9970 90 20.9080 90 21.0840 /
\plot 100 21.0020 100 20.9600 100 21.0430 /
\plot 110 21.0020 110 20.9710 110 21.0340 /
\plot 120 21.0020 120 20.9730 120 21.0310 /
\plot 130 21.0010 130 20.9740 130 21.0270 /
\plot 140 21.0000 140 20.9740 140 21.0270 /
\plot 150 20.9980 150 20.9690 150 21.0270 /
\plot 160 20.9910 160 20.9570 160 21.0260 /
\plot 170 20.9850 170 20.9390 170 21.0300 /
\plot 180 20.9920 180 20.9270 180 21.0550 /
\endpicture
\caption{Implied Volatility with Confidence Intervals (Q2)}
\end{figure}


\newpage








\section*{Question 3: Implied Volatility for \(\alpha = 0.02, \beta = 0, \gamma = 0.98\)}
\addcontentsline{toc}{section}{Question 3: \(\alpha = 0.02, \beta = 0, \gamma = 0.98\)}

With parameters $\alpha = 0.02$, $\beta = 0$, and $\gamma = 0.98$, the GARCH(1,1) model becomes:

\[ \sigma_t^2 = 0.02\sigma_{\text{LT}}^2 + 0.98\sigma_{t-1}^2 \]

In this setting, the daily volatility process is primarily driven by past volatility $\gamma = 0.98$, but still reacts to new information via return shocks, $\alpha = 0.02$. Since $\beta = 0$, the volatility barely changes overtime, which causes the implied volatility to remain mostly flat across strikes, similarly to problem 2; however, the call options have an overall volatility close to 27\% since $\alpha$ being at 2\% causes some shocks and fluctuations, increasing the volatility from 21\% to approximately 27\%. \\






\begin{figure}[h!]
\centering
\beginpicture
\setcoordinatesystem units <.04truein, .2truein> 
\setplotarea x from 75 to 185, y from  19 to 29
\put {Implied Volatility with Confidence Intervals (Q3)} at 130 29
\axis left ticks numbered from 19 to 29 by 1 /
\axis bottom ticks numbered from 80 to 180 by 10 /
\setplotsymbol ({$\cdot$})
\plot 80 27.0270 80 26.8780 80 27.1730 /
\plot 90 27.0480 90 26.9880 90 27.1070 /
\plot 100 27.0470 100 27.0090 100 27.0860 /
\plot 110 27.0520 110 27.0200 110 27.0840 /
\plot 120 27.0530 120 27.0240 120 27.0820 /
\plot 130 27.0520 130 27.0250 130 27.0790 /
\plot 140 27.0500 140 27.0240 140 27.0760 /
\plot 150 27.0550 150 27.0280 150 27.0810 /
\plot 160 27.0530 160 27.0240 160 27.0820 /
\plot 170 27.0510 170 27.0190 170 27.0840 /
\plot 180 27.0460 180 27.0070 180 27.0840 /
\endpicture
\caption{Implied Volatility with Confidence Intervals (Q3)}
\end{figure}



\newpage









\section*{Question 4: Implied Volatility for \(\alpha = 0.007, \beta = 0.080, \gamma = 0.913\)}
\addcontentsline{toc}{section}{Question 4: \(\alpha = 0.007, \beta = 0.080, \gamma = 0.913\)}

With parameters \( \alpha = 0.007, \beta = 0.080, \gamma = 0.913 \), both return shocks and past volatility influence \( \sigma_t^2 \):
\[ \sigma_t^2 = 0.007\sigma_{\text{LT}}^2 + 0.080 R_{t-1}^2 + 0.913 \sigma_{t-1}^2 \]

This combination leads to a volatility process that is both persistent and responsive to market shocks. Compared to Question 2, which has constant volatility, this model introduces stochastic volatility and realistic time-varying behavior. Compared to Question 3, where \( \beta = 0 \), it includes direct dependence and persistence on past variance. \\

This persistence produces realistic features like volatility clustering and fatter tails in return distributions. These features result in a more pronounced implied volatility smile: implied volatility is higher for lower and higher strikes, while low for strikes somewhere in between. This reflects real-world option markets, where far-from-the-money options tend to be more expensive due to increased uncertainty and perceived risk.





\begin{figure}[h!]
\centering
\beginpicture
\setcoordinatesystem units <.04truein, .2truein> 
\setplotarea x from 75 to 185, y from  19 to 29
\put {Implied Volatility with Confidence Intervals (Q4)} at 130 29
\axis left ticks numbered from 19 to 29 by 1 /
\axis bottom ticks numbered from 80 to 180 by 10 /
\setplotsymbol ({$\cdot$})
\plot 80 27.4520 80 27.2960 80 27.6040 /
\plot 90 25.5740 90 25.5030 90 25.6450 /
\plot 100 24.3110 100 24.2680 100 24.3540 /
\plot 110 23.6200 110 23.5870 110 23.6530 /
\plot 120 23.4280 120 23.3980 120 23.4570 /
\plot 130 23.6340 130 23.6060 130 23.6620 /
\plot 140 24.1490 140 24.1200 140 24.1780 /
\plot 150 24.8750 150 24.8420 150 24.9070 /
\plot 160 25.7360 160 25.6970 160 25.7740 /
\plot 170 26.6790 170 26.6320 170 26.7260 /
\plot 180 27.6650 180 27.6060 180 27.7220 /
\endpicture
\caption{Implied Volatility with Confidence Intervals (Q4)}
\end{figure}



\newpage










\section*{Conclusion:}

In this project, we employed Monte Carlo simulation techniques, enhanced with antithetic variates, to estimate European call option prices under various GARCH(1,1) volatility models. Our results illustrate how different parameter choices in the GARCH model influence the implied volatility surface. \\

When volatility is constant with \( \gamma = 1 \), the implied volatility remains flat, in line with the assumptions of the Black-Scholes model. Introducing non-zero parameters for \( \alpha \) and \( \beta \) adds realistic features such as implied volatility smiles, which better reflect actual market behavior. \\

This study underscores the importance of GARCH models in capturing more realistic volatility dynamics in financial markets. It also provides insight into the sensitivity of option pricing to the structure of volatility. Through our simulations and analysis, we observed how volatility modeling directly impacts option valuation and risk assessment, demonstrating the practical value of GARCH models in pricing options and managing risk in financial markets. \\




\section*{Contributions:}
We all worked together on the coding of each problem to ensure that there were no discrepancies. We provided feedback and clarified the details throughout the process, refining our implementations until all discrepancies were resolved. Once we finalized the code, we worked on the report together, and we made sure to include sufficient detail, ensure proper formatting, and maintain clarity throughout.
\newpage

\section*{Appendix:}
Code for Problem 1:
\begin{lstlisting}[language=C++]
#include "Functions.h"

int main () {

   int i, n, N;
   double s0, s1, s2, T, r, sigma, sigma2, sigma2_0, sigma2_1, sigma2_2;
   double mu, alpha, beta, gamma, dt, Z, R1, R2, U, sigma2_LT;
   double sum_payoffs, sum_payoffs_squared, payoff, error;
   int M;

   alpha = 0.007;
   beta = 0.080;
   gamma = 0.913;

   sigma2_0 = 0.1610 * 0.1610; // (initial vol 21% annualized)
   
   // Time to expiration
   T = 0.5;

   // Risk-free interest rate
   r = 0.05;

   // Number of days to expiration (252 trading days per year)
   N = (int)(252 * T);
   dt = 1.0/252.0;

   // Adjust risk-free rate to daily
   r *= dt;

   // Initial stock price
   s0 = 116.99;

   // Initial daily variance
   sigma2_0 *= dt;

   // Long-run annual variance and daily variance
   sigma2_LT = 0.30 * 0.30;
   sigma2_LT *= dt;

   // Seed the RNG
   MTUniform();

   // Initialize accumulators
   M = 0;
   sum_payoffs = 0.0;
   sum_payoffs_squared = 0.0;
   error = 1.0;

   // Begin simulations until standard error is below threshold
   while (error >= 0.01) {

      M++;

      // Initialize s1, s2 and sigma2_1, sigma2_2
      s1 = s0;
      s2 = s0;
      sigma2_1 = sigma2_0;
      sigma2_2 = sigma2_0;

      // Simulate day by day
      for (i = 1; i <= N; i++) {
         // Generate a uniform random number and convert it to standard normal
         U = MTUniform();
         Z = PsiInv(U);

         // Calculate current volatilities (standard deviation)
         double sigma1 = sqrt(sigma2_1);
         double sigma2 = sqrt(sigma2_2);

         // Calculate the drifts
         double mu1 = r - 0.5 * sigma2_1;
         double mu2 = r - 0.5 * sigma2_2;

         // Compute returns for normal and antithetic paths
         R1 = sigma1 * Z;
         R2 = sigma2 * (-Z);

         // Update stock prices
         s1 *= exp(mu1 + R1);
         s2 *= exp(mu2 + R2);

         // Update volatilities
         sigma2_1 = alpha * sigma2_LT + beta * R1*R1 + gamma * sigma2_1;
         sigma2_2 = alpha * sigma2_LT + beta * R2*R2 + gamma * sigma2_2;
      }

      // Compute discounted average payoff using antithetic variates
      payoff = 0.5 * exp(-0.05 * T) * (s1 + s2);

      // Update accumulators
      sum_payoffs += payoff;
      sum_payoffs_squared += payoff * payoff;

      // Update standard error 
      if (M > 1) {
         double mean = sum_payoffs / M;
         double variance = (sum_payoffs_squared - M * mean * mean) / (M-1);
         error = sqrt(variance / M);
      }
   }

   // Final option value
   double option_price = sum_payoffs / M;

   printf("Simulations: %d\n", M);
   printf("Estimated Option Value: %.5f\n", option_price);
   printf("Standard Error: %.5f\n", error);

   return 0;
}
\end{lstlisting}
\newpage
Code for Problems 2-4:
\begin{lstlisting}[language=C++]
#include "Functions.h"

int main() {
    int i, j, n, K;
    const int NUM_PATHS = 100000;     // Number of Monte Carlo simulations
    const int NUM_STRIKES = 11;       // Number of strike prices to evaluate
    double S0 = 116.99;               // Initial stock price
    double r = 0.05;                  // Risk-free interest rate
    double T = 0.5;                   // Time to maturity (in years)
    double sigma0 = 0.21;             // Initial volatility
    double sigma_LT = 0.30;           // Long-term volatility
    double dt = 1.0 / 252.0;          // Daily time step (252 trading days/year)
    int N = (int)(T * 252);           // Total time steps in the simulation

    // Volatility squared times dt (used for updating variance)
    double sigma2_0 = sigma0 * sigma0 * dt;
    double sigma2_LT = sigma_LT * sigma_LT * dt;

    // Ask user which volatility model parameters to use
    n = GetInteger("Which problem (2, 3, or 4) are you working on?... ");
    double alpha, beta, gamma;

    // Assign model parameters based on user selection
    if (n == 2) {
        alpha = 0.0; beta = 0.0; gamma = 1.0;         // Constant volatility
    } else if (n == 3) {
        alpha = 0.02; beta = 0.0; gamma = 0.98;       
    } else {
        alpha = 0.007; beta = 0.080; gamma = 0.913;   
    }

    // Define strike prices: 80, 90, ..., 180
    double strikes[NUM_STRIKES];
    for (i = 0; i < NUM_STRIKES; i++)
        strikes[i] = 80 + i * 10;

    MTUniform();  // Initialize random number generator

    // Print table headers
    printf("\nStrike     Price     95%% CI               ImpliedVol     LowerCI     UpperCI\n");
    printf("======     =====     ==================    ===========    ========    ========\n");

    // Loop over each strike price
    for (i = 0; i < NUM_STRIKES; i++) {
        K = strikes[i];
        double sum = 0.0, sum2 = 0.0;

        // Begin simulation
        for (j = 0; j < NUM_PATHS; j++) {
            // Start prices for two antithetic paths
            double S1 = S0, S2 = S0;                     
            double sigma2_1 = sigma2_0, sigma2_2 = sigma2_0;

            // Simulate the entire path for both S1 and S2 (antithetic variates)
            for (int t = 0; t < N; t++) {
                double U = MTUniform();
                double Z = PsiInv(U);                    // Standard normal variable
                double Z_antithetic = -Z;                // Antithetic counterpart

                double sigma1 = sqrt(sigma2_1);
                double sigma2 = sqrt(sigma2_2);

                double R1 = sigma1 * Z;
                double R2 = sigma2 * Z_antithetic;

                double mu1 = r * dt - 0.5 * sigma2_1;
                double mu2 = r * dt - 0.5 * sigma2_2;

                // Update asset prices using lognormal model
                S1 *= exp(mu1 + R1);
                S2 *= exp(mu2 + R2);

                // Update variance using chosen volatility model
                sigma2_1 = alpha * sigma2_LT + beta * R1 * R1 + gamma * sigma2_1;
                sigma2_2 = alpha * sigma2_LT + beta * R2 * R2 + gamma * sigma2_2;
            }

            // Calculate payoffs for call options
            double payoff1 = fmax(S1 - K, 0.0);
            double payoff2 = fmax(S2 - K, 0.0);
            double avg_payoff = 0.5 * (payoff1 + payoff2);  // Use antithetic average

            sum += avg_payoff;
            sum2 += avg_payoff * avg_payoff;
        }

        // Estimate expected value and standard deviation
        double mean_undiscounted = sum / NUM_PATHS;
        double stdev_undiscounted = sqrt((sum2 / NUM_PATHS - mean_undiscounted * mean_undiscounted) / NUM_PATHS);

        // Discount the expected value and confidence interval bounds
        double discount_factor = exp(-r * T);
        double option_price = discount_factor * mean_undiscounted;
        double conf_int_low = discount_factor * (mean_undiscounted - 1.96 * stdev_undiscounted);
        double conf_int_high = discount_factor * (mean_undiscounted + 1.96 * stdev_undiscounted);

        // Estimate implied volatilities for price and confidence bounds
        double vol = ImpliedVol(T, S0, K, r, option_price);
        double vol_low = ImpliedVol(T, S0, K, r, conf_int_low);
        double vol_high = ImpliedVol(T, S0, K, r, conf_int_high);

        // Output results for this strike
        printf(" %5d    %7.4f   [%.4f, %.4f]   %10.4f   %8.4f   %8.4f\n",
               K, option_price, conf_int_low, conf_int_high, vol, vol_low, vol_high);
    }

    return 0;
}
\end{lstlisting}


\pagebreak


\end{document}
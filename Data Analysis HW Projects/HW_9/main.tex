\documentclass{report}
\setlength{\parindent}{0pt} % Sets the automatic indent size
\usepackage{graphicx} % Required for inserting images
\usepackage{pictex}   % Ensure PicTeX is available
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}


\lstset{
    language=C++,
    basicstyle=\ttfamily\tiny,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    numbers=none,
    numberstyle=\tiny,
    stepnumber=1,
    breaklines=true,
    frame=single,
    captionpos=b,
    showstringspaces=false
}

\title{HW\#9}
\author{
Elhaam Bhuiyan,
Amir Samarxhiu,
Shaqib Syed
}
\date{May 11, 2025}

\begin{document}

\maketitle

\section*{Introduction}

\textit{Funky Bonds Are Us} has engaged \textbf{Golden Stacks} to provide a rigorous valuation of two structured interest rate derivatives: the \textbf{Funky Collar} and the \textbf{Funky Put}. These securities exhibit complex pay-off structures and are highly sensitive to the evolution of the interest rate environment. Initial simulation-based approaches proved computationally inefficient, prompting the development of efficient and recursively implemented valuation models. \\

This report presents the results of these models. We begin by detailing the structure and valuation methodology for each instrument. We then assess their present value using market data as of May 8, which includes a Nelson-Siegel fit of the U.S. Treasury par curve with a short rate of 4.24\%, long rate of 4.92\%, and a hump of â€“0.95\%. A short-rate volatility of 15\% is assumed. \\

The \textbf{Funky Collar} pays a lump sum at year 10, contingent on the frequency of short-rate excursions outside a specified corridor. The \textbf{Funky Put} is a stylized American-style instrument that allows the holder to demand payment at an optimal stopping time. Recursive methods are used to compute fair values and optimal strategies for both instruments. The accompanying source files, \texttt{Collar-Rec.cpp} and \texttt{Put-Rec.cpp}, contain our full implementations, confined to the functions \texttt{ValueCollar()} and \texttt{ValuePut()} as required. \\

\newpage

\section*{Results}

\subsection*{The Funky Put}

The Funky Put is an American-style interest rate option that gives the holder the right to demand a one-time payment at any semiannual interval over a 30-year horizon. Specifically, at any time $t \in \{0.5, 1.0, ..., 30\} \text{ years}$, they can demand a payment of $\frac{t}{30} \times 100 \text{ million USD}$. Our challenge is to determine the optimal stopping time that maximizes the expected present value of the payment while balancing the trade-off between a growing nominal payoff and discounting driven by unpredictable future interest rates. \\

We can model this evolution of interest rates using a recombinant binomial tree. We can let each node represent a specific time step $n$ and interest rate state $i$. Time advances in increments of 0.5 years, where $n \in \{0, 1, ..., 60\}$. At each node $\left(n, i\right)$, the discount factor $d(n, i)$ is provided by the model's calibration process and used to discount future values one period backward in the lattice. \\

The option value at each node, $P(n, i)$ is computed recursively through dynamic programming. For each node, we have to consider whether the immediate exercise value is greater than the expected continuation value. The immediate exercise value is the payment the holder would receive if they chose to exercise the option now:
\[
\text{Exercise}(n) = \frac{100 \text{MM} \cdot n}{60}
\]
To calculate the continuation value, we must consider the two possible rate transitions for each node in the binomial tree. The interest rate either increases to $(n, i + 1)$ or decreases to $(n, i - 1)$ with equal probability. The continuation value is calculated by discounting the expected value of the option in the next time step:
\[
\text{Continuation}(n, i) = d(n, i) \cdot \frac{1}{2}\left[P(n + 1, i + 1) + P(n + 1, i - 1)\right]
\]

We can generalize the recursive formula as:
\[
P(n, i)=\max \left(\text{Exercise}(n), \text{Continuation}(n, i)\right)
\]

Once the recursion reaches the final time step $n = 60$, the holder is forced to exercise:
\[
P(60, i)=\frac{100 \text{MM} \cdot 60}{60}=100 \text{MM}
\]

From there, we work backwards through the lattice, computing $P(n, i)$ for each node using our formula above. This recursive solution is efficient because we can use memoization to store values of $P(n, i)$ to avoid recomputation. Furthermore, since the binomial tree has 61 levels with $2n + 1$ nodes on each level, the total number of function calls this recursive method uses is $\sum_{n=0}^{60}\left(2n+1\right)=3721$, provided that memoization is implemented correctly. This makes the recursive approach exceptionally quick. \\

We also record a decision flag $S(n, i)$ where $S(n, i)= 1$ if exercising is optimal at that node, and $S(n, i)=0$ if it is better to wait. This is used to generate the following exercise boundary plot:\\

\def\smallbullet{\scriptscriptstyle\bullet}
\def\smallcircle{\scriptscriptstyle\circ}
\beginpicture
\setcoordinatesystem units <.15truein, .13truein> 
\setplotarea x from 0 to 30, y from  0 to 15
\axis left 
 label {(\%)} 
 ticks   numbered from  0 to 15 by 1  
 /

\axis bottom
label {Years}
ticks  numbered from 0 to 30 by 5
/
% Un-comment the next two lines when these two txt files are created.
\multiput {$\smallbullet$} at "Put.txt"
\multiput {$\smallcircle$} at "NotPut.txt"
\put {\sl $\smallbullet\ = $ Exercise, $\smallcircle\ = $ Continue} at 15 17
\endpicture 

In the early years (closer to year 0), it is almost always better to wait. This is because the final payment increases over time, and waiting gives the chance for a higher payout. However, as we get closer to year 30, it becomes more attractive to demand the payment early especially when interest rates are high. High interest rates reduce the value of waiting, so the strategy shifts to exercising the put sooner. \\

The Funky Put is described as a "put" because it grants the holder the right to demand payment at a time of their choosing to maximize present value. Similar to an American put option, it becomes optimal to exercise when market conditions worsen (in this case, when interest rates rise). Since higher rates reduce the present value of future payments due to steeper discounting, the holder is incentivized to demand payment immediately, similar to how a put option is exercised when the value of the underlying asset declines. \\

To validate our approach, we first tested our implementation under a flat 5\% yield curve with zero volatility. From the assignment, the theoretical maximum value of the Funky Put was \$24.8 million when exercised at 20.5 years. Our implementation matched this, yielding \$24.83 million. Under the full model with the May 8 par curve and 15\% volatility, our code produced a value of \$28.60 million which is consistent with the expected output provided in the assignment.

\subsection*{The Funky Collar}

The Funky Collar is a path-dependent interest rate derivative that pays a single lump sum payment at year 10 based on how often the short-term interest rate falls outside a predefined band. More precisely, the contract pays \$5 million for each semiannual period over 10 years in which the 6-month par rate lies outside the range $[3\%, 7\%]$. There are 20 such periods, and the total payout is $\$5\text{MM} \times k$, where $k$ is the number of periods in which the rate falls beyond the collar bounds.\\

To model this instrument, we will use a similar structure to the Funky Put. We use a recombinant binomial tree with time steps of 0.5 years. Each node $(n, i)$ corresponds to a time $n$ and rate state $i$, and we track the number of collar bound violations up to that point using a third index $k$. The value function $C(n, i, k)$ represents the expected discount value of the collar at that node, given $k$ previous collar bound violations. \\

At each node, we check whether the current 6-month par rate is outside the collar band using \texttt{ParRate(n, i, n + 1)}. If it is, the number of collar bound violations is incremented. Similar to the Funky Put, the value is then computed recursively by averaging the values at the next time step along each rate transition path, and discounting back using the local discount factor $d(n, i)$:
\[
C(n, i, k) = d(n, i) \cdot \frac{1}{2} \left[ C(n+1, i-1, k') + C(n+1, i+1, k') \right]
\]
where $k' = k + 1$ if the rate is outside the collar, and $k' = k$ otherwise. \\

At maturity ($n = 20$), the value is simply:
\[
C(20, i, k)= 5 \cdot k \quad \text{(in millions)}
\]

This recursive process continues backwards through the lattice, beginning with the terminal payoff. Compared to the simulation approach, the recursive approach is much more efficient. Since the binomial tree has 21 time steps, $2n + 1$ nodes per time step, and up to 21 possible collar bound violations, the maximum number of function calls is $21 \cdot \sum_{n=0}^{20} (2n+1)=9261$, provided that memoization is implemented. \\

Unlike the Funky Put, this collar instrument has no optionality. In other words, the holder cannot choose when to exercise or intervene; it simply accumulates value passively based on rate behavior. This means that it is less sensitive to strategic timing and more directly affected by interest rate volatility. \\

To validate our implementation, we ran the model using the May 8 Treasury par curve and a short-rate volatility of 15\%. Our recursive implementation returned a collar value of \$14.09MM, which is consistent with the expected value of \$14.1MM provided in the assignment brief.

\subsection*{Par Yield Curve}


The graph below shows the U.S. Treasury par yield curve as of May 8, 2025, alongside the best-fit Nelson-Siegel model. Each open circle represents observed par yields at various maturities, while the dotted line is the smooth curve fitted by the Nelson-Siegel formula. This yield curve captures market expectations for future interest rates and serves as the input for discounting future cash flows in both the Funky Put and Funky Collar valuations. The upward slope of the curve implies higher long-term rates, which affects the present value of distant cash flows and the optimal strategy for exercising interest rate options. \\

\def\smallbullet{\scriptstyle\bullet}
\def\smallcircle{\scriptstyle\circ}
\beginpicture
\setcoordinatesystem units <.15truein, .2truein> 
\setplotarea x from 0 to 30, y from  0 to 8
\axis left 
 label {(\%)} 
 ticks   numbered from  0 to 8 by 1  
 /
\axis bottom
label {Maturity}
ticks in numbered from 0 to 30 by 5
/
\put {\sl 5/8/2025 Par Treasury Yields with Best Nelson-Siegel Fit} at 15 9

%Treasury par yield curve on 5/8/2025:
\multiput{$\smallcircle$} at 0.5  4.28  1  4.05  2  3.90  3  3.85 5  4.00  7  4.18  10  4.37  20  4.86  30  4.83   /

%Three parameter Nelson-Siegel fit of the par curve
\setplotsymbol ({$\cdot$})
\plot "par.txt"

\endpicture

\newpage

\section*{Conclusion}

Our recursive valuation framework provides efficient and accurate estimates for two complex assets: the Funky Put and the Funky Collar. By modeling the evolution of the short rate using a binomial tree consistent with the May 8 U.S. Treasury par curve and applying 15\% volatility, we have captured both path-dependence and strategic decision-making under uncertainty. \\

The Funky Put, with its embedded optionality and optimal stopping feature, emerges as the more valuable instrument, worth \$28.6\,\text{MM.} Its flexibility to choose the exercise time allows the holder to exploit favorable rate movements, especially under high volatility. In contrast, the Funky Collarâ€™s path-dependent structure yields a more limited payoff of \$14.1\,\text{MM,} as it lacks timing optionality and is capped by the number of periods the rate exceeds its bounds. \\

Overall, this analysis underscores the significant impact of optionality, interest rate volatility, and path-dependence on derivative valuation. The recursive methods implemented in \texttt{Put-Rec.cpp} and \texttt{Collar-Rec.cpp} strike a balance between computational tractability and modeling realism, providing a robust toolkit for evaluating similar structured products. \\


\section*{Contributions}
We all worked together to code each problem to ensure there were no discrepancies. We provided feedback and clarified the details throughout the process, refining our implementations until all discrepancies were resolved. Once we finalized the code, we worked on the report together, and we made sure to include sufficient detail, ensure proper formatting, and maintain clarity throughout.

\newpage
\section*{Appendix:}

Code for Funky Collar:

\begin{lstlisting}[language=C++]


////////////////////////////////////////////////////////////////////////////////
// Recursively value the collar.
////////////////////////////////////////////////////////////////////////////////
double ValueCollar(int n, int i, int k) {
   // If already computed, return already computed value value
   if (C[n][i][k] > 0.0) return C[n][i][k];

   // Terminal node (after 10 years = 20 semiannual periods)
   if (n == 20) {
      C[n][i][k] = 5.0 * k;  // $5MM Ã— number of outside periods
      return C[n][i][k];
   }

   // Get the short rate at this node (semiannual compounding)
   double r = ParRate(n, i, n+1);  // in percent

   // Check if the short rate is outside the collar band [3%, 7%]
   int new_k = k;
   if (r < flr || r > cap) new_k++;

   // Value from up and down states
   double Vu = ValueCollar(n+1, i+1, new_k);
   double Vd = ValueCollar(n+1, i-1, new_k);

   // Expected value discounted back one period
   C[n][i][k] = 0.5 * (Vu + Vd) * d[n][i];

   return C[n][i][k];
}


\end{lstlisting}
\newpage
Code for Funky Put:
\begin{lstlisting}[language=C++]


double ValuePut (int n, int i) {
   // Terminal node: after 30 years = 60 half-year periods
   printf("P[%d][%d] = %.6f\n", n, i, P[n][i]);
   if (n == 60) {
      S[n][i] = 1;  // Always demand at maturity
      P[n][i] = Payment(n);
      return P[n][i];
   }
   // Check and see if put value is already computed
   if (P[n][i] > 0.0) {
      return P[n][i];
   }
   // Exercise now
   double exercise = Payment(n);

   // Continue with expected discounted value of future
   double up = ValuePut(n + 1, i + 1);
   double down = ValuePut(n + 1, i - 1);
   double continuation = 0.5 * d[n][i] * (up + down);

   // Choose the better option
   if (exercise >= continuation) {
      S[n][i] = 1; // Demand payment now
      P[n][i] = exercise;
   } else {
      S[n][i] = 0; // Wait
      P[n][i] = continuation;
   }

   return P[n][i];
}

\end{lstlisting}

\end{document}
